'\" t
.\"     Title: gpsd_json
.\"    Author: [see the "AUTHOR" section]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 23 June 2019
.\"    Manual: GPSD Documentation
.\"    Source: The GPSD Project
.\"  Language: English
.\"
.TH "GPSD_JSON" "5" "23 June 2019" "The GPSD Project" "GPSD Documentation"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
gpsd_json \- gpsd request/response protocol
.SH "OVERVIEW"
.PP
gpsd
is a service daemon that can be used to monitor GPSes, DGPS receivers, Marine AIS broadcasts, and various other location\-related and kinematic sensors\&.
.PP
Clients may communicate with
gpsd
via textual requests and responses over a socket\&. It is a bad idea for applications to speak the protocol directly: rather, they should use the
libgps
client library (for C; bindings also exist for other languages) and take appropriate care to conditionalize their code on the major and minor protocol version symbols\&.
.PP
The GPSD protocol is built on top of JSON, JavaScript Object Notation, as specified in RFC 7159:
The JavaScript Object Notation (JSON) Data Interchange Format\&. GPSD\*(Aqs use of JSON is restricted in some ways that make parsing it in fixed\-extent languages (such as C) easier\&.
.PP
A request line is introduced by "?" and may include multiple commands\&. Commands begin with a command identifier, followed either by a terminating \*(Aq;\*(Aq or by an equal sign "=" and a JSON object treated as an argument\&. Any \*(Aq;\*(Aq or newline indication (either LF or CR\-LF) after the end of a command is ignored\&. All request lines must be composed of US\-ASCII characters and may be no more than 80 characters in length, exclusive of the trailing newline\&.
.PP
Responses are JSON objects all of which have a "class" attribute the value of which is either the name of the invoking command\&. There are reports (including but not limited to as "TPV", "SKY", "DEVICE", and "ERROR") which are not direct responses to commands\&.
.PP
The order of JSON attributes within a response object is never significant, and you may specify attributes in commands in any order\&. Responses never contain the special JSON value null; instead, attributes with empty or undefined values are omitted\&. The length limit for responses and reports is 1536 characters, including trailing newline; longer responses will be truncated, so client code must be prepared for the possibility of invalid JSON fragments\&.
.PP
In JSON reports, if an attribute is present only if the parent attribute is present or has a particular range, then the parent attribute is emitted first\&.
.PP
There is one constraint on the order in which attributes will be omitted\&. If an optional attribute is present only when a parent attribute has a specified value or range of values, the parent attribute will be emitted first to make parsing easier\&.
.PP
The next subsection section documents the core GPSD protocol\&. Extensions are documented in the following subsections\&. The extensions may not be supported in your
gpsd
instance if it has been compiled with a restricted feature set\&.
.SH "CORE SOCKET PROTOCOL"
.PP
Here are the core\-protocol responses:
.PP
TPV
.RS 4
A TPV object is a time\-position\-velocity report\&. The "class" and "mode" fields will reliably be present\&. The "mode" field will be emitted before optional fields that may be absent when there is no fix\&. Error estimates will be emitted after the fix components they\*(Aqre associated with\&. Others may be reported or not depending on the fix quality\&.
.sp
All error estimates (epc, epd, epe, eph, ept, epv, epx, epy) are assumed to be 95% confidence, may also be 50%, one sigma, or two sigma confidence\&. Many GPS do not specify a confidence level\&. No GPS specifies how the value is calculated\&. Use error estimates with caution, and only as relative "goodness" indicators\&. If the GPS reports a value to gpsd, then gpsd will report that value\&. Otherwise gpsd will try to compute the value from the skyview\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&1.\ \&TPV object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "TPV"
T}
T{
device
T}:T{
No
T}:T{
string
T}:T{
Name of originating device\&.
T}
T{
status
T}:T{
No
T}:T{
numeric
T}:T{
GPS status: %d, 2=DGPS fix, otherwise not present\&.
T}
T{
mode
T}:T{
Yes
T}:T{
numeric
T}:T{
NMEA mode: %d, 0=no mode value yet seen, 1=no fix, 2=2D, 3=3D\&.
T}
T{
time
T}:T{
No
T}:T{
string
T}:T{
Time/date stamp in ISO8601 format, UTC\&. May have a
	fractional part of up to \&.001sec precision\&. May be absent if mode
        is not 2 or 3\&.
T}
T{
altHAE
T}:T{
No
T}:T{
numeric
T}:T{
Altitude, height above allipsoid, in meters\&.  Probably
WGS84\&. Present if mode is 3\&.
T}
T{
altMSL
T}:T{
No
T}:T{
numeric
T}:T{
MSL Altitude in meters\&.  The geoid used is rarely specified
and is often inacurate\&.  See the comments below on geoidSep\&.  Present if
 mode is 3\&.  altMSL is altHAE \- geoidSep\&.
T}
T{
alt
T}:T{
No
T}:T{
numeric
T}:T{
Deprecated\&.  Undefined\&.  Use altHAE or altMSL\&.
T}
T{
climb
T}:T{
No
T}:T{
numeric
T}:T{
Climb (positive) or sink (negative) rate, meters per
	second\&.
T}
T{
datum
T}:T{
No
T}:T{
string
T}:T{
Current datum\&.
T}
T{
depth
T}:T{
No
T}:T{
numeric
T}:T{
Depth in meters\&.  Probably depth below the keel\&.\&.
T}
T{
dgpsAge
T}:T{
No
T}:T{
numeric
T}:T{
Age of DGPS data\&. In seconds
T}
T{
dgpsSta
T}:T{
No
T}:T{
numeric
T}:T{
Station of DGPS data\&.
T}
T{
epc
T}:T{
No
T}:T{
numeric
T}:T{
Estimated climb error in meters per second\&. Present
        if consecutive 3D fixes\&.
T}
T{
epd
T}:T{
No
T}:T{
numeric
T}:T{
Estimated track (direction) error in degrees\&. Present if
        consecutive 2D fixes\&.
T}
T{
eph
T}:T{
No
T}:T{
numeric
T}:T{
Estimated horizontal Position (2D) Error in meters\&.
        Also known as Estimated Position Error (epe)\&. Present
        if mode is 2D or 3D and DOPs can be calculated from the satellite
        view\&.
T}
T{
eps
T}:T{
No
T}:T{
numeric
T}:T{
Estimated speed error in meters per second\&.  Present
        for consecutive 2D or 3D fixes\&.
T}
T{
ept
T}:T{
No
T}:T{
numeric
T}:T{
Estimated timestamp error in seconds\&.
        Present if time is present\&.
T}
T{
epx
T}:T{
No
T}:T{
numeric
T}:T{
Longitude error estimate in meters\&. Present
        if mode is 2D or 3D and DOPs can be calculated from the satellite
        view\&.
T}
T{
epy
T}:T{
No
T}:T{
numeric
T}:T{
Latitude error estimate in meters\&. Present
        if mode is 2 or 3 and DOPs can be calculated from the satellite
        view\&.
T}
T{
epv
T}:T{
No
T}:T{
numeric
T}:T{
Estimated vertical error in meters\&. Present
        if mode is 3 and DOPs can be calculated from the satellite
        view\&.
T}
T{
lat
T}:T{
No
T}:T{
numeric
T}:T{
Latitude in degrees: +/\- signifies North/South\&.  Present
        when mode is 2 or 3\&.
T}
T{
leapseconds
T}:T{
integer
T}:T{
Current leap seconds\&.
T}
T{
lon
T}:T{
No
T}:T{
numeric
T}:T{
Longitude in degrees: +/\- signifies East/West\&. Present
        when mode is 2 or 3\&.
T}
T{
track
T}:T{
No
T}:T{
numeric
T}:T{
Course over ground, degrees from true north\&.
T}
T{
magtrack
T}:T{
No
T}:T{
numeric
T}:T{
Course over ground, degrees magnetic\&.
T}
T{
magvar
T}:T{
No
T}:T{
numeric
T}:T{
Magnetic variation, degrees\&.  Also known as
the magnetic declination (the direction of the horizontal component of
the magnetic field measured clockwise from north) in degrees,
Positive is West variation\&.  Negative is East variation\&.
T}
T{
speed
T}:T{
No
T}:T{
numeric
T}:T{
Speed over ground, meters per second\&.
T}
T{
ecefx
T}:T{
No
T}:T{
numeric
T}:T{
ECEF X position in meters\&.
T}
T{
ecefy
T}:T{
No
T}:T{
numeric
T}:T{
ECEF Y position in meters\&.
T}
T{
ecefz
T}:T{
No
T}:T{
numeric
T}:T{
ECEF Z position in meters\&.
T}
T{
ecefpAcc
T}:T{
No
T}:T{
numeric
T}:T{
ECEF position error in meters\&.
T}
T{
ecefvx
T}:T{
No
T}:T{
numeric
T}:T{
ECEF X velocity in meters/second\&.
T}
T{
ecefvy
T}:T{
No
T}:T{
numeric
T}:T{
ECEF Y velocity in meters/second\&.
T}
T{
ecefvz
T}:T{
No
T}:T{
numeric
T}:T{
ECEF Z velocity in meters/second\&.
T}
T{
ecefvAcc
T}:T{
No
T}:T{
numeric
T}:T{
ECEF velocity error in meters/second\&.
T}
T{
sep
T}:T{
No
T}:T{
numeric
T}:T{
Estimated Spherical (3D) Position Error in meters\&.
         Present if mode is 3D and DOPs can be calculated from the satellite
        view\&. Assumed to be 95% confidence, but many GPS do not specify\&.
T}
T{
relN
T}:T{
No
T}:T{
numeric
T}:T{
North component of relative position vector in meters\&.
T}
T{
relE
T}:T{
No
T}:T{
numeric
T}:T{
East component of relative position vector in meters\&.
T}
T{
relD
T}:T{
No
T}:T{
numeric
T}:T{
Down component of relative position vector in meters\&.
T}
T{
velN
T}:T{
No
T}:T{
numeric
T}:T{
North velocity component in meters\&.
T}
T{
velE
T}:T{
No
T}:T{
numeric
T}:T{
wEast velocity component in meters\&.
T}
T{
velD
T}:T{
No
T}:T{
numeric
T}:T{
Down velocity component in meters\&.
T}
T{
geoidSep
T}:T{
No
T}:T{
numeric
T}:T{
Geoid separation is the difference between the WGS84
reference elipsoid and the geoid (Mean Sea Level) in meters\&.  Almost no
GNSS receiver specifies how they compute their geoid\&. gpsd interpolates the
geoid from a 5x5 degree table of EGM2008 values when the receiver does
not supply a geoid separation\&.  The gpsd computed geoidSep is usually
within one meter of the "true" value, but can be off as much as 12 meters\&.
T}
.TE
.sp 1
When the C client library parses a response of this kind, it will assert validity bits in the top\-level set member for each field actually received; see gps\&.h for bitmask names and values\&.
.sp
Invalid or known floating point values will be set to NAN\&.
.sp
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"TPV","device":"/dev/pts/1",
    "time":"2005\-06\-08T10:34:48\&.283Z","ept":0\&.005,
    "lat":46\&.498293369,"lon":7\&.567411672,"alt":1343\&.127,
    "eph":36\&.000,"epv":32\&.321,
    "track":10\&.3788,"speed":0\&.091,"climb":\-0\&.085,"mode":3}
.fi
.if n \{\
.RE
.\}
.RE
.PP
SKY
.RS 4
A SKY object reports a sky view of the GPS satellite positions\&. If there is no GPS device available, or no skyview has been reported yet, only the "class" field will reliably be present\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&2.\ \&SKY object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "SKY"
T}
T{
device
T}:T{
No
T}:T{
string
T}:T{
Name of originating device
T}
T{
time
T}:T{
No
T}:T{
string
T}:T{
Time/date stamp in ISO8601 format, UTC\&. May have a
	fractional part of up to \&.001sec precision\&.
T}
T{
gdop
T}:T{
No
T}:T{
numeric
T}:T{
Geometric (hyperspherical) dilution of precision, a
        combination of PDOP and TDOP\&.  A dimensionless factor which
        should be multiplied by a base UERE
        to get an error estimate\&.
T}
T{
hdop
T}:T{
No
T}:T{
numeric
T}:T{
Horizontal dilution of precision, a dimensionless
	factor which should be multiplied by a base UERE to get a
	circular error estimate\&.
T}
T{
pdop
T}:T{
No
T}:T{
numeric
T}:T{
Position (spherical/3D)  dilution of precision, a dimensionless
	factor which should be multiplied by a base UERE to get an
	error estimate\&.
T}
T{
tdop
T}:T{
No
T}:T{
numeric
T}:T{
Time dilution of precision, a dimensionless
	factor which should be multiplied by a base UERE to get an
	error estimate\&.
T}
T{
vdop
T}:T{
No
T}:T{
numeric
T}:T{
Vertical (altitude) dilution of precision, a dimensionless
	factor which should be multiplied by a base UERE to get an
	error estimate\&.
T}
T{
xdop
T}:T{
No
T}:T{
numeric
T}:T{
Longitudinal dilution of precision, a dimensionless
	factor which should be multiplied by a base UERE to get an
	error estimate\&.
T}
T{
ydop
T}:T{
No
T}:T{
numeric
T}:T{
Latitudinal dilution of precision, a dimensionless
	factor which should be multiplied by a base UERE to get an
	error estimate\&.
T}
T{
satellites
T}:T{
Yes
T}:T{
list
T}:T{
List of satellite objects in skyview
T}
.TE
.sp 1
Many devices compute dilution of precision factors but do not include them in their reports\&. Many that do report DOPs report only HDOP, two\-dimensional circular error\&.
gpsd
always passes through whatever the device actually reports, then attempts to fill in other DOPs by calculating the appropriate determinants in a covariance matrix based on the satellite view\&. DOPs may be missing if some of these determinants are singular\&. It can even happen that the device reports an error estimate in meters when the corresponding DOP is unavailable; some devices use more sophisticated error modeling than the covariance calculation\&.
.sp
The satellite list objects have the following elements:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&3.\ \&Satellite object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l.
T{
PRN
T}:T{
Yes
T}:T{
numeric
T}:T{
PRN ID of the satellite\&. 1\-63 are GNSS satellites,
	64\-96 are GLONASS satellites, 100\-164 are SBAS satellites
T}
T{
az
T}:T{
No
T}:T{
numeric
T}:T{
Azimuth, degrees from true north\&.
T}
T{
el
T}:T{
No
T}:T{
numeric
T}:T{
Elevation in degrees\&.
T}
T{
ss
T}:T{
No
T}:T{
numeric
T}:T{
Signal to Noise ratio in dBHz\&.
T}
T{
used
T}:T{
Yes
T}:T{
boolean
T}:T{
Used in current solution? (SBAS/WAAS/EGNOS satellites
	may be flagged used if the solution has corrections from them,
	but not all drivers make this information available\&.)
T}
T{
gnssid
T}:T{
No
T}:T{
numeric
T}:T{
The GNSS ID, as defined by u\-blox, not NMEA\&.  0=GPS,
        2=Galileo, 3=Beidou, 5=QZSS, 6\-GLONASS\&.
T}
T{
svid
T}:T{
no
T}:T{
numeric
T}:T{
The satellite ID within its constellation\&.  As defined
        by u\-blox, not NMEA)\&.
T}
T{
sigid
T}:T{
no
T}:T{
numeric
T}:T{
The signal ID of this signal\&.  As defined by u\-blox, not
        NMEA\&. See u\-blox doc for details\&.
T}
T{
freqid
T}:T{
no
T}:T{
numeric
T}:T{
For GLONASS satellites only: the frequency ID of the signal\&.
As defined by u\-blox, range 0 to 13\&.  The freqid is the frequency slot
plus 7\&.
T}
T{
health
T}:T{
no
T}:T{
numeric
T}:T{
The health of this satellite\&.  0 is unknown, 1 is
OK, and 2 is unhealthy\&.
T}
.TE
.sp 1
Note that satellite objects do not have a "class" field, as they are never shipped outside of a SKY object\&.
.sp
When the C client library parses a SKY response, it will assert the SATELLITE_SET bit in the top\-level set member\&.
.sp
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"SKY","device":"/dev/pts/1",
    "time":"2005\-07\-08T11:28:07\&.114Z",
    "xdop":1\&.55,"hdop":1\&.24,"pdop":1\&.99,
    "satellites":[
        {"PRN":23,"el":6,"az":84,"ss":0,"used":false},
        {"PRN":28,"el":7,"az":160,"ss":0,"used":false},
        {"PRN":8,"el":66,"az":189,"ss":44,"used":true},
        {"PRN":29,"el":13,"az":273,"ss":0,"used":false},
        {"PRN":10,"el":51,"az":304,"ss":29,"used":true},
        {"PRN":4,"el":15,"az":199,"ss":36,"used":true},
        {"PRN":2,"el":34,"az":241,"ss":43,"used":true},
        {"PRN":27,"el":71,"az":76,"ss":43,"used":true}]}
.fi
.if n \{\
.RE
.\}
.RE
.PP
GST
.RS 4
A GST object is a pseudorange noise report\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&4.\ \&GST object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "GST"
T}
T{
device
T}:T{
No
T}:T{
string
T}:T{
Name of originating device
T}
T{
time
T}:T{
No
T}:T{
string
T}:T{
Time/date stamp in ISO8601 format, UTC\&. May have a
	fractional part of up to \&.001sec precision\&.
T}
T{
rms
T}:T{
No
T}:T{
numeric
T}:T{
Value of the standard deviation of the range inputs to the
navigation process (range inputs include pseudoranges and DGPS
corrections)\&.
T}
T{
major
T}:T{
No
T}:T{
numeric
T}:T{
Standard deviation of semi\-major axis of error ellipse, in meters\&.
T}
T{
minor
T}:T{
No
T}:T{
numeric
T}:T{
Standard deviation of semi\-minor axis of error ellipse, in meters\&.
T}
T{
orient
T}:T{
No
T}:T{
numeric
T}:T{
Orientation of semi\-major axis of error ellipse, in degrees from true north\&.
T}
T{
lat
T}:T{
No
T}:T{
numeric
T}:T{
Standard deviation of latitude error, in meters\&.
T}
T{
lon
T}:T{
No
T}:T{
numeric
T}:T{
Standard deviation of longitude error, in meters\&.
T}
T{
alt
T}:T{
No
T}:T{
numeric
T}:T{
Standard deviation of altitude error, in meters\&.
T}
.TE
.sp 1
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"GST","device":"/dev/ttyUSB0",
        "time":"2010\-12\-07T10:23:07\&.096Z","rms":2\&.440,
        "major":1\&.660,"minor":1\&.120,"orient":68\&.989,
        "lat":1\&.600,"lon":1\&.200,"alt":2\&.520}
.fi
.if n \{\
.RE
.\}
.RE
.PP
ATT
.RS 4
An ATT object is a vehicle\-attitude report\&. It is returned by digital\-compass and gyroscope sensors; depending on device, it may include: heading, pitch, roll, yaw, gyroscope, and magnetic\-field readings\&. Because such sensors are often bundled as part of marine\-navigation systems, the ATT response may also include water depth\&.
.sp
The "class" and "mode" fields will reliably be present\&. Others may be reported or not depending on the specific device type\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&5.\ \&ATT object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "ATT"
T}
T{
device
T}:T{
Yes
T}:T{
string
T}:T{
Name of originating device
T}
T{
time
T}:T{
No
T}:T{
string
T}:T{
Time/date stamp in ISO8601 format, UTC\&. May have a
	fractional part of up to \&.001sec precision\&.
T}
T{
heading
T}:T{
No
T}:T{
numeric
T}:T{
Heading, degrees from true north\&.
T}
T{
mag_st
T}:T{
No
T}:T{
string
T}:T{
Magnetometer status\&.
T}
T{
pitch
T}:T{
No
T}:T{
numeric
T}:T{
Pitch in degrees\&.
T}
T{
pitch_st
T}:T{
No
T}:T{
string
T}:T{
Pitch sensor status\&.
T}
T{
yaw
T}:T{
No
T}:T{
numeric
T}:T{
Yaw in degrees
T}
T{
yaw_st
T}:T{
No
T}:T{
string
T}:T{
Yaw sensor status\&.
T}
T{
roll
T}:T{
No
T}:T{
numeric
T}:T{
Roll in degrees\&.
T}
T{
roll_st
T}:T{
No
T}:T{
string
T}:T{
Roll sensor status\&.
T}
T{
dip
T}:T{
No
T}:T{
numeric
T}:T{
Local magnetic inclination, degrees, positive when the magnetic
field points downward (into the Earth)\&.
T}
T{
mag_len
T}:T{
No
T}:T{
numeric
T}:T{
Scalar magnetic field strength\&.
T}
T{
mag_x
T}:T{
No
T}:T{
numeric
T}:T{
X component of magnetic field strength\&.
T}
T{
mag_y
T}:T{
No
T}:T{
numeric
T}:T{
Y component of magnetic field strength\&.
T}
T{
mag_z
T}:T{
No
T}:T{
numeric
T}:T{
Z component of magnetic field strength\&.
T}
T{
acc_len
T}:T{
No
T}:T{
numeric
T}:T{
Scalar acceleration\&.
T}
T{
acc_x
T}:T{
No
T}:T{
numeric
T}:T{
X component of acceleration\&.
T}
T{
acc_y
T}:T{
No
T}:T{
numeric
T}:T{
Y component of acceleration\&.
T}
T{
acc_z
T}:T{
No
T}:T{
numeric
T}:T{
Z component of acceleration\&.
T}
T{
gyro_x
T}:T{
No
T}:T{
numeric
T}:T{
X component of acceleration\&.
T}
T{
gyro_y
T}:T{
No
T}:T{
numeric
T}:T{
Y component of acceleration\&.
T}
T{
depth
T}:T{
No
T}:T{
numeric
T}:T{
Water depth in meters\&.
T}
T{
temp
T}:T{
No
T}:T{
numeric
T}:T{
Temperature at sensor, degrees centigrade\&.
T}
.TE
.sp 1
The heading, pitch, and roll status codes (if present) vary by device\&. For the TNT Revolution digital compasses, they are coded as follows:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&6.\ \&Device flags
.TS
allbox tab(:);
lB lB.
T{
Code
T}:T{
Description
T}
.T&
l l
l l
l l
l l
l l
l l
l l.
T{
C
T}:T{
magnetometer calibration alarm
T}
T{
L
T}:T{
low alarm
T}
T{
M
T}:T{
low warning
T}
T{
N
T}:T{
normal
T}
T{
O
T}:T{
high warning
T}
T{
P
T}:T{
high alarm
T}
T{
V
T}:T{
magnetometer voltage level alarm
T}
.TE
.sp 1
When the C client library parses a response of this kind, it will assert ATT_IS\&.
.sp
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"ATT","time":1270938096\&.843,
    "heading":14223\&.00,"mag_st":"N",
    "pitch":169\&.00,"pitch_st":"N", "roll":\-43\&.00,"roll_st":"N",
    "dip":13641\&.000,"mag_x":2454\&.000}
.fi
.if n \{\
.RE
.\}
.RE
.PP
And here are the commands:
.PP
?VERSION;
.RS 4
Returns an object with the following attributes:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&7.\ \&VERSION object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "VERSION"
T}
T{
release
T}:T{
Yes
T}:T{
string
T}:T{
Public release level
T}
T{
rev
T}:T{
Yes
T}:T{
string
T}:T{
Internal revision\-control level\&.
T}
T{
proto_major
T}:T{
Yes
T}:T{
numeric
T}:T{
API major revision level\&.
T}
T{
proto_minor
T}:T{
Yes
T}:T{
numeric
T}:T{
API minor revision level\&.
T}
T{
remote
T}:T{
No
T}:T{
string
T}:T{
URL of the remote daemon reporting this version\&. If
        empty, this is the version of the local daemon\&.
T}
.TE
.sp 1
The daemon ships a VERSION response to each client when the client first connects to it\&.
.sp
When the C client library parses a response of this kind, it will assert the VERSION_SET bit in the top\-level set member\&.
.sp
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"VERSION","version":"2\&.40dev",
    "rev":"06f62e14eae9886cde907dae61c124c53eb1101f",
    "proto_major":3,"proto_minor":1
}
.fi
.if n \{\
.RE
.\}
.RE
.PP
?DEVICES;
.RS 4
Returns a device list object with the following elements:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&8.\ \&DEVICES object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "DEVICES"
T}
T{
devices
T}:T{
Yes
T}:T{
list
T}:T{
List of device descriptions
T}
T{
remote
T}:T{
No
T}:T{
string
T}:T{
URL of the remote daemon reporting the device set\&. If
        empty, this is a DEVICES response from the local daemon\&.
T}
.TE
.sp 1
When the C client library parses a response of this kind, it will assert the DEVICELIST_SET bit in the top\-level set member\&.
.sp
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class"="DEVICES","devices":[
    {"class":"DEVICE","path":"/dev/pts/1","flags":1,"driver":"SiRF binary"},
    {"class":"DEVICE","path":"/dev/pts/3","flags":4,"driver":"AIVDM"}]}
.fi
.if n \{\
.RE
.\}
.sp
The daemon occasionally ships a bare DEVICE object to the client (that is, one not inside a DEVICES wrapper)\&. The data content of these objects will be described later as a response to the ?DEVICE command\&.
.RE
.PP
?WATCH;
.RS 4
This command sets watcher mode\&. It also sets or elicits a report of per\-subscriber policy and the raw bit\&. An argument WATCH object changes the subscriber\*(Aqs policy\&. The response describes the subscriber\*(Aqs policy\&. The response will also include a DEVICES object\&.
.sp
A WATCH object has the following elements:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&9.\ \&WATCH object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "WATCH"
T}
T{
enable
T}:T{
No
T}:T{
boolean
T}:T{
Enable (true) or disable (false) watcher mode\&. Default
	is true\&.
T}
T{
json
T}:T{
No
T}:T{
boolean
T}:T{
Enable (true) or disable (false) dumping of JSON reports\&.
	Default is false\&.
T}
T{
nmea
T}:T{
No
T}:T{
boolean
T}:T{
Enable (true) or disable (false) dumping of binary
	packets as pseudo\-NMEA\&. Default
	is false\&.
T}
T{
raw
T}:T{
No
T}:T{
integer
T}:T{
Controls \*(Aqraw\*(Aq mode\&. When this attribute is set to 1
	for a channel, gpsd reports the
	unprocessed NMEA or AIVDM data stream from whatever device is attached\&.
	Binary GPS packets are hex\-dumped\&.  RTCM2 and RTCM3
        packets are not dumped in raw mode\&. When this attribute is set to
	2 for a channel that processes binary data,
	gpsd reports the received data verbatim
	without hex\-dumping\&.
T}
T{
scaled
T}:T{
No
T}:T{
boolean
T}:T{
If true, apply scaling divisors to output before
	dumping; default is false\&.
T}
T{
split24
T}:T{
No
T}:T{
boolean
T}:T{
If true, aggregate AIS type24 sentence parts\&.  If false,
        report each part as a separate JSON object, leaving the
        client to match MMSIs and aggregate\&.  Default is
        false\&. Applies only to AIS reports\&.
T}
T{
pps
T}:T{
No
T}:T{
boolean
T}:T{
If true, emit the TOFF JSON message on each cycle and a
	PPS JSON message when the device issues 1PPS\&. Default is false\&.
T}
T{
device
T}:T{
No
T}:T{
string
T}:T{
If present, enable watching only of the specified device
	rather than all devices\&.  Useful with raw and NMEA modes
	in which device responses aren\*(Aqt tagged\&. Has no effect when
	used with enable:false\&.
T}
T{
remote
T}:T{
No
T}:T{
string
T}:T{
URL of the remote daemon reporting the watch set\&. If
        empty, this is a WATCH response from the local daemon\&.
T}
.TE
.sp 1
There is an additional boolean "timing" attribute which is undocumented because that portion of the interface is considered unstable and for developer use only\&.
.sp
In watcher mode, GPS reports are dumped as TPV and SKY responses\&. AIS, Subframe and RTCM reporting is described in the next section\&.
.sp
When the C client library parses a response of this kind, it will assert the POLICY_SET bit in the top\-level set member\&.
.sp
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"WATCH", "raw":1,"scaled":true}
.fi
.if n \{\
.RE
.\}
.RE
.PP
?POLL;
.RS 4
The POLL command requests data from the last\-seen fixes on all active GPS devices\&. Devices must previously have been activated by ?WATCH to be pollable\&.
.sp
Polling can lead to possibly surprising results when it is used on a device such as an NMEA GPS for which a complete fix has to be accumulated from several sentences\&. If you poll while those sentences are being emitted, the response will contain the last complete fix data and may be as much as one cycle time (typically 1 second) stale\&.
.sp
The POLL response will contain a timestamped list of TPV objects describing cached data, and a timestamped list of SKY objects describing satellite configuration\&. If a device has not seen fixes, it will be reported with a mode field of zero\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&10.\ \&POLL object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "POLL"
T}
T{
time
T}:T{
Yes
T}:T{
Numeric
T}:T{
Timestamp in ISO 8601 format\&. May have a
	fractional part of up to \&.001sec precision\&.
T}
T{
active
T}:T{
Yes
T}:T{
Numeric
T}:T{
Count of active devices\&.
T}
T{
tpv
T}:T{
Yes
T}:T{
JSON array
T}:T{
Comma\-separated list of TPV objects\&.
T}
T{
sky
T}:T{
Yes
T}:T{
JSON array
T}:T{
Comma\-separated list of SKY objects\&.
T}
.TE
.sp 1
Here\*(Aqs an example of a POLL response:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"POLL","time":"2010\-06\-04T10:31:00\&.289Z","active":1,
    "tpv":[{"class":"TPV","device":"/dev/ttyUSB0",
            "time":"2010\-09\-08T13:33:06\&.095Z",
	    "ept":0\&.005,"lat":40\&.035093060,
            "lon":\-75\&.519748733,"track":99\&.4319,"speed":0\&.123,"mode":2}],
    "sky":[{"class":"SKY","device":"/dev/ttyUSB0",
            "time":1270517264\&.240,"hdop":9\&.20,
            "satellites":[{"PRN":16,"el":55,"az":42,"ss":36,"used":true},
                          {"PRN":19,"el":25,"az":177,"ss":0,"used":false},
                          {"PRN":7,"el":13,"az":295,"ss":0,"used":false},
                          {"PRN":6,"el":56,"az":135,"ss":32,"used":true},
                          {"PRN":13,"el":47,"az":304,"ss":0,"used":false},
                          {"PRN":23,"el":66,"az":259,"ss":0,"used":false},
                          {"PRN":20,"el":7,"az":226,"ss":0,"used":false},
                          {"PRN":3,"el":52,"az":163,"ss":32,"used":true},
                          {"PRN":31,"el":16,"az":102,"ss":0,"used":false}
]}]}
.fi
.if n \{\
.RE
.\}
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Client software should not assume the field inventory of the POLL response is fixed for all time\&. As
gpsd
collects and caches more data from more sensor types, those data are likely to find their way into this response\&.
.sp .5v
.RE
.RE
.PP
TOFF
.RS 4
This message is emitted on each cycle and reports the offset between the host\*(Aqs clock time and the GPS time at top of second (actually, when the first data for the reporting cycle is received)\&.
.sp
This message exactly mirrors the PPS message except for two details\&.
.sp
TOFF emits no NTP precision, this is assumed to be \-2\&. See the NTP documentation for their definition of precision\&.
.sp
The TOFF message reports the GPS time as derived from the GPS serial data stream\&. The PPS message reports the GPS time as derived from the GPS PPS pulse\&.
.sp
A TOFF object has the following elements:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&11.\ \&TOFF object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "TOFF"
T}
T{
device
T}:T{
Yes
T}:T{
string
T}:T{
Name of originating device
T}
T{
real_sec
T}:T{
Yes
T}:T{
numeric
T}:T{
seconds from the GPS clock
T}
T{
real_nsec
T}:T{
Yes
T}:T{
numeric
T}:T{
nanoseconds from the GPS clock
T}
T{
clock_sec
T}:T{
Yes
T}:T{
numeric
T}:T{
seconds from the system clock
T}
T{
clock_nsec
T}:T{
Yes
T}:T{
numeric
T}:T{
nanoseconds from the system clock
T}
.TE
.sp 1
This message is emitted once per second to watchers of a device and is intended to report the time stamps of the in\-band report of the GPS and seconds as reported by the system clock (which may be NTP\-corrected) when the first valid timestamp of the reporting cycle was seen\&.
.sp
The message contains two second/nanosecond pairs: real_sec and real_nsec contain the time the GPS thinks it was at the start of the current cycle; clock_sec and clock_nsec contain the time the system clock thinks it was on receipt of the first timing message of the cycle\&. real_nsec is always to nanosecond precision\&. clock_nsec is nanosecond precision on most systems\&.
.sp
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"TOFF","device":"/dev/ttyUSB0",
     "real_sec":1330212592, "real_nsec":343182,
     "clock_sec":1330212592,"clock_nsec":343184,
     "precision":\-2}}
.fi
.if n \{\
.RE
.\}
.RE
.PP
PPS
.RS 4
This message is emitted each time the daemon sees a valid PPS (Pulse Per Second) strobe from a device\&.
.sp
This message exactly mirrors the TOFF message except for two details\&.
.sp
PPS emits the NTP precision\&. See the NTP documentation for their definition of precision\&.
.sp
The TOFF message reports the GPS time as derived from the GPS serial data stream\&. The PPS message reports the GPS time as derived from the GPS PPS pulse\&.
.sp
There are various sources of error in the reported clock times\&. The speed of the serial connection between the GPS and the system adds a delay to start of cycle detection\&. An even bigger error is added by the variable computation time inside the GPS\&. Taken together the time derived from the start of the GPS cycle can have offsets of 10 millisecond to 700 milliseconds and combined jjitter and wander of 100 to 300 millisecond\&.
.sp
A PPS object has the following elements:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&12.\ \&PPS object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "PPS"
T}
T{
device
T}:T{
Yes
T}:T{
string
T}:T{
Name of originating device
T}
T{
real_sec
T}:T{
Yes
T}:T{
numeric
T}:T{
seconds from the PPS source
T}
T{
real_nsec
T}:T{
Yes
T}:T{
numeric
T}:T{
nanoseconds from the PPS source
T}
T{
clock_sec
T}:T{
Yes
T}:T{
numeric
T}:T{
seconds from the system clock
T}
T{
clock_nsec
T}:T{
Yes
T}:T{
numeric
T}:T{
nanoseconds from the system clock
T}
T{
precision
T}:T{
Yes
T}:T{
numeric
T}:T{
NTP style estimate of PPS precision
T}
T{
qErr
T}:T{
No
T}:T{
numeric
T}:T{
Quantization error of the PPS, in pico seconds\&.  Sometimes
called the "sawtooth" error\&.
T}
.TE
.sp 1
This message is emitted once per second to watchers of a device emitting PPS, and reports the time of the start of the GPS second (when the 1PPS arrives) and seconds as reported by the system clock (which may be NTP\-corrected) at that moment\&.
.sp
The message contains two second/nanosecond pairs: real_sec and real_nsec contain the time the GPS thinks it was at the PPS edge; clock_sec and clock_nsec contain the time the system clock thinks it was at the PPS edge\&. real_nsec is always to nanosecond precision\&. clock_nsec is nanosecond precision on most systems\&.
.sp
There are various sources of error in the reported clock times\&. For PPS delivered via a real serial\-line strobe, serial\-interrupt latency plus processing time to the timer call should be bounded above by about 10 microseconds; that can be reduced to less than 1 microsecond if your kernel supports RFC 2783\&. USB1\&.1\-to\-serial control\-line emulation is limited to about 1 millisecond\&. seconds\&.
.sp
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"PPS","device":"/dev/ttyUSB0",
     "real_sec":1330212592, "real_nsec":343182,
     "clock_sec":1330212592,"clock_nsec":343184,
     "precision":\-3}
.fi
.if n \{\
.RE
.\}
.RE
.PP
OSC
.RS 4
This message reports the status of a GPS\-disciplined oscillator (GPSDO)\&. The GPS PPS output (which has excellent long\-term stability) is typically used to discipline a local oscillator with much better short\-term stability (such as a rubidium atomic clock)\&.
.sp
An OSC object has the following elements:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&13.\ \&OSC object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "OSC"
T}
T{
device
T}:T{
Yes
T}:T{
string
T}:T{
Name of originating device\&.
T}
T{
running
T}:T{
Yes
T}:T{
boolean
T}:T{
If true, the oscillator is currently running\&.  Oscillators may require warm\-up time at start of day\&.
T}
T{
reference
T}:T{
Yes
T}:T{
boolean
T}:T{
If true, the oscillator is receiving a GPS PPS signal\&.
T}
T{
disciplined
T}:T{
Yes
T}:T{
boolean
T}:T{
If true, the GPS PPS signal is sufficiently stable and is being used to discipline the local oscillator\&.
T}
T{
delta
T}:T{
Yes
T}:T{
numeric
T}:T{
The time difference (in nanoseconds) between the GPS\-disciplined oscillator PPS output pulse and the most recent GPS PPS input pulse\&.
T}
.TE
.sp 1
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"OSC","running":true,"device":"/dev/ttyUSB0",
    "reference":true,"disciplined":true,"delta":67}
.fi
.if n \{\
.RE
.\}
.RE
.PP
?DEVICE
.RS 4
This command reports (when followed by \*(Aq;\*(Aq) the state of a device, or sets (when followed by \*(Aq=\*(Aq and a DEVICE object) device\-specific control bits, notably the device\*(Aqs speed and serial mode and the native\-mode bit\&. The parameter\-setting form will be rejected if more than one client is attached to the channel\&.
.sp
Pay attention to the response, because it is possible for this command to fail if the GPS does not support a speed\-switching command or only supports some combinations of serial modes\&. In case of failure, the daemon and GPS will continue to communicate at the old speed\&.
.sp
Use the parameter\-setting form with caution\&. On USB and Bluetooth GPSes it is also possible for serial mode setting to fail either because the serial adaptor chip does not support non\-8N1 modes or because the device firmware does not properly synchronize the serial adaptor chip with the UART on the GPS chipset when the speed changes\&. These failures can hang your device, possibly requiring a GPS power cycle or (in extreme cases) physically disconnecting the NVRAM backup battery\&.
.sp
A DEVICE object has the following elements:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&14.\ \&DEVICE object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "DEVICE"
T}
T{
path
T}:T{
No
T}:T{
string
T}:T{
Name the device for which the control bits are
	being reported, or for which they are to be applied\&. This
        attribute may be omitted only when there is exactly one
        subscribed channel\&.
T}
T{
activated
T}:T{
No
T}:T{
string
T}:T{
Time the device was activated as an ISO8601
        timestamp\&. If the device is inactive this attribute is
        absent\&.
T}
T{
flags
T}:T{
No
T}:T{
integer
T}:T{
Bit vector of property flags\&.  Currently defined flags are:
        describe packet types seen so far (GPS, RTCM2, RTCM3,
	AIS)\&. Won\*(Aqt be reported if empty, e\&.g\&. before
	gpsd has seen identifiable packets
	from the device\&.
T}
T{
driver
T}:T{
No
T}:T{
string
T}:T{
GPSD\*(Aqs name for the device driver type\&. Won\*(Aqt be reported before
	gpsd has seen identifiable packets
	from the device\&.
T}
T{
subtype
T}:T{
No
T}:T{
string
T}:T{
Whatever version information the device driver returned\&.
T}
T{
subtype1
T}:T{
No
T}:T{
string
T}:T{
More version information the device driver returned\&.
T}
T{
bps
T}:T{
No
T}:T{
integer
T}:T{
Device speed in bits per second\&.
T}
T{
parity
T}:T{
No
T}:T{
string
T}:T{
N, O or E for no parity, odd, or even\&.
T}
T{
stopbits
T}:T{
Yes
T}:T{
string
T}:T{
Stop bits (1 or 2)\&.
T}
T{
native
T}:T{
No
T}:T{
integer
T}:T{
0 means NMEA mode and 1 means
	alternate mode (binary if it has one, for SiRF and Evermore chipsets
	in particular)\&. Attempting to set this mode on a non\-GPS
	device will yield an error\&.
T}
T{
cycle
T}:T{
No
T}:T{
real
T}:T{
Device cycle time in seconds\&.
T}
T{
mincycle
T}:T{
No
T}:T{
real
T}:T{
Device minimum cycle time in seconds\&. Reported from
	?DEVICE when (and only when) the rate is switchable\&. It is
	read\-only and not settable\&.
T}
.TE
.sp 1
The serial parameters will (bps, parity, stopbits) be omitted in a response describing a TCP/IP source such as an Ntrip, DGPSIP, or AIS feed; on a serial device they will always be present\&.
.sp
The contents of the flags field should be interpreted as follows:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&15.\ \&Device flags
.TS
allbox tab(:);
lB lB lB.
T{
C #define
T}:T{
Value
T}:T{
Description
T}
.T&
l l l
l l l
l l l
l l l.
T{
SEEN_GPS
T}:T{
0x01
T}:T{
GPS data has been seen on this device
T}
T{
SEEN_RTCM2
T}:T{
0x02
T}:T{
RTCM2 data has been seen on this device
T}
T{
SEEN_RTCM3
T}:T{
0x04
T}:T{
RTCM3 data has been seen on this device
T}
T{
SEEN_AIS
T}:T{
0x08
T}:T{
AIS data has been seen on this device
T}
.TE
.sp 1
When the C client library parses a response of this kind, it will assert the DEVICE_SET bit in the top\-level set member\&.
.sp
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"DEVICE","bps":4800,"parity":"N","stopbits":1,"native":0}
.fi
.if n \{\
.RE
.\}
.RE
.PP
When a client is in watcher mode, the daemon will ship it DEVICE notifications when a device is added to the pool or deactivated\&.
.PP
When the C client library parses a response of this kind, it will assert the DEVICE_SET bit in the top\-level set member\&.
.PP
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"DEVICE","path":"/dev/pts1","activated":0}
.fi
.if n \{\
.RE
.\}
.PP
The daemon may ship an error object in response to a syntactically invalid command line or unknown command\&. It has the following elements:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&16.\ \&ERROR notification object
.TS
allbox tab(:);
lB lB lB lB.
T{
Name
T}:T{
Always?
T}:T{
Type
T}:T{
Description
T}
.T&
l l l l
l l l l.
T{
class
T}:T{
Yes
T}:T{
string
T}:T{
Fixed: "ERROR"
T}
T{
message
T}:T{
Yes
T}:T{
string
T}:T{
Textual error message
T}
.TE
.sp 1
.PP
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"ERROR","message":"Unrecognized request \*(Aq?FOO\*(Aq"}
.fi
.if n \{\
.RE
.\}
.PP
When the C client library parses a response of this kind, it will assert the ERR_SET bit in the top\-level set member\&.
.SH "RTCM2"
.PP
RTCM\-104 is a family of serial protocols used for broadcasting pseudorange corrections from differential\-GPS reference stations\&. Many GPS receivers can accept these corrections to improve their reporting accuracy\&.
.PP
RTCM\-104 comes in two major and incompatible flavors, 2\&.x and 3\&.x\&. Each major flavor has minor (compatible) revisions\&.
.PP
The applicable standard for RTCM Version 2\&.x is
RTCM Recommended Standards for Differential NAVSTAR GPS Service
RTCM Paper 194\-93/SC 104\-STD\&. For RTCM 3\&.1 it is
RTCM Paper 177\-2006\-SC104\-STD\&. Ordering instructions for both standards are accessible from the website of the
\m[blue]\fBRadio Technical Commission for Maritime Services\fR\m[]\&\s-2\u[1]\d\s+2
under "Publications"\&.
.SS "RTCM WIRE TRANSMISSIONS"
.PP
Differential\-GPS correction stations consist of a GPS reference receiver coupled to a low frequency (LF) transmitter\&. The GPS reference receiver is a survey\-grade GPS that does GPS carrier tracking and can work out its own position to a few millimeters\&. It generates range and range\-rate corrections and encodes them into RTCM104\&. It ships the RTCM104 to the LF transmitter over serial rs\-232 signal at 100 baud or 200 baud depending on the requirements of the transmitter\&.
.PP
The LF transmitter broadcasts the approximately 300khz radio signal that differential\-GPS radio receivers pick up\&. Transmitters that are meant to have a higher range will need to transmit at the slower rate\&. The higher the data rate the harder it will be for the remote radio receiver to receive with a good signal\-to\-noise ration\&. (Higher data rate signals can\*(Aqt be averaged over as long a time frame, hence they appear noisier\&.)
.SS "RTCM WIRE FORMATS"
.PP
An RTCM 2\&.x message consists of a sequence of up to 33 30\-bit words\&. The 24 most significant bits of each word are data and the six least significant bits are parity\&. The parity algorithm used is the same ISGPS\-2000 as that used on GPS satellite downlinks\&. Each RTCM 2\&.x message consists of two header words followed by zero or more data words, depending upon message type\&.
.PP
An RTCM 3\&.x message begins with a fixed leader byte 0xD3\&. That is followed by six bits of version information and 10 bits of payload length information\&. Following that is the payload; following the payload is a 3\-byte checksum of the payload using the Qualcomm CRC\-24Q algorithm\&.
.SS "RTCM2 JSON FORMAT"
.PP
Each RTCM2 message is dumped as a single JSON object per message, with the message fields as attributes of that object\&. Arrays of satellite, station, and constellation statistics become arrays of JSON sub\-objects\&. Each sentence will normally also have a "device" field containing the pathname of the originating device\&.
.PP
All attributes other than the device field are mandatory\&. Header attributes are emitted before others\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBHeader portion\fR
.RS 4
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&17.\ \&SKY object
.TS
allbox tab(:);
lB lB lB.
T{
Name
T}:T{
Type
T}:T{
.PP
Description
T}
.T&
l l l
l l l
l l l
l l l
l l l
l l l
l l l.
T{
class
T}:T{
string
T}:T{
.PP
Fixed: "RTCM2"\&.
T}
T{
type
T}:T{
integer
T}:T{
.PP
Message type (1\-9)\&.
T}
T{
station_id
T}:T{
integer
T}:T{
.PP
The id of the GPS reference receiver\&. The LF transmitters also have (different) id numbers\&.
T}
T{
zcount
T}:T{
real
T}:T{
.PP
The reference time of the corrections in the message in seconds within the current hour\&. Note that it is in GPS time, which is some seconds ahead of UTC (see the U\&.S\&. Naval Observatory\*(Aqs
\m[blue]\fBtable of leap second corrections\fR\m[]\&\s-2\u[2]\d\s+2)\&.
T}
T{
seqnum
T}:T{
integer
T}:T{
.PP
Sequence number\&. Only 3 bits wide, wraps after 7\&.
T}
T{
length
T}:T{
integer
T}:T{
.PP
The number of words after the header that comprise the message\&.
T}
T{
station_health
T}:T{
integer
T}:T{
.PP
Station transmission status\&. Indicates the health of the beacon as a reference source\&. Any nonzero value means the satellite is probably transmitting bad data and should not be used in a fix\&. 6 means the transmission is unmonitored\&. 7 means the station is not working properly\&. Other values are defined by the beacon operator\&.
T}
.TE
.sp 1
.PP
<message type> is one of
.PP
1
.RS 4
full corrections \- one message containing corrections for all GPS satellites in view\&. This is not common\&.
.RE
.PP
3
.RS 4
reference station parameters \- the position of the reference station GPS antenna\&.
.RE
.PP
4
.RS 4
datum \(em the datum to which the DGPS data is referred\&.
.RE
.PP
5
.RS 4
constellation health \(em information about the satellites the beacon can see\&.
.RE
.PP
6
.RS 4
null message \(em just a filler\&.
.RE
.PP
7
.RS 4
radio beacon almanac \(em information about this or other beacons\&.
.RE
.PP
9
.RS 4
subset corrections \(em a message containing corrections for only a subset of the GPS satellites in view\&.
.RE
.PP
16
.RS 4
special message \(em a text message from the beacon operator\&.
.RE
.PP
31
.RS 4
GLONASS subset corrections \(em a message containing corrections for a set of the GLONASS satellites in view\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBType 1 and 9: Correction data\fR
.RS 4
.PP
One or more satellite objects follow the header for type 1 or type 9 messages\&. Here is the format:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&18.\ \&Satellite object
.TS
allbox tab(:);
lB lB lB.
T{
Name
T}:T{
Type
T}:T{
.PP
Description
T}
.T&
l l l
l l l
l l l
l l l
l l l.
T{
ident
T}:T{
integer
T}:T{
.PP
The PRN number of the satellite for which this is correction data\&.
T}
T{
udre
T}:T{
integer
T}:T{
.PP
User Differential Range Error (0\-3)\&. See the table following for values\&.
T}
T{
iod
T}:T{
integer
T}:T{
.PP
Issue Of Data, matching the IOD for the current ephemeris of this satellite, as transmitted by the satellite\&. The IOD is a unique tag that identifies the ephemeris; the GPS using the DGPS correction and the DGPS generating the data must use the same orbital positions for the satellite\&.
T}
T{
prc
T}:T{
real
T}:T{
.PP
The pseudorange error in meters for this satellite as measured by the beacon reference receiver at the epoch indicated by the z_count in the parent record\&.
T}
T{
rrc
T}:T{
real
T}:T{
.PP
The rate of change of pseudorange error in meters/sec for this satellite as measured by the beacon reference receiver at the epoch indicated by the z_count field in the parent record\&. This is used to calculate pseudorange errors at other epochs, if required by the GPS receiver\&.
T}
.TE
.sp 1
.PP
User Differential Range Error values are as follows:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&19.\ \&UDRE values
.TS
allbox tab(:);
l l
l l
l l
l l.
T{
0
T}:T{
1\-sigma error	<= 1m
T}
T{
1
T}:T{
1\-sigma error	<= 4m
T}
T{
2
T}:T{
1\-sigma error	<= 8m
T}
T{
3
T}:T{
1\-sigma error	>  8m
T}
.TE
.sp 1
.PP
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"RTCM2","type":1,
    "station_id":688,"zcount":843\&.0,"seqnum":5,"length":19,"station_health":6,
    "satellites":[
	{"ident":10,"udre":0,"iod":46,"prc":\-2\&.400,"rrc":0\&.000},
	{"ident":13,"udre":0,"iod":94,"prc":\-4\&.420,"rrc":0\&.000},
	{"ident":7,"udre":0,"iod":22,"prc":\-5\&.160,"rrc":0\&.002},
	{"ident":2,"udre":0,"iod":34,"prc":\-6\&.480,"rrc":0\&.000},
	{"ident":4,"udre":0,"iod":47,"prc":\-8\&.860,"rrc":0\&.000},
	{"ident":8,"udre":0,"iod":76,"prc":\-7\&.980,"rrc":0\&.002},
	{"ident":5,"udre":0,"iod":99,"prc":\-8\&.260,"rrc":0\&.002},
	{"ident":23,"udre":0,"iod":81,"prc":\-8\&.060,"rrc":0\&.000},
	{"ident":16,"udre":0,"iod":70,"prc":\-11\&.740,"rrc":0\&.000},
	{"ident":30,"udre":0,"iod":4,"prc":\-18\&.960,"rrc":\-0\&.006},
	{"ident":29,"udre":0,"iod":101,"prc":\-24\&.960,"rrc":\-0\&.002}
]}
.fi
.if n \{\
.RE
.\}
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBType 3: Reference Station Parameters\fR
.RS 4
.PP
Here are the payload members of a type 3 (Reference Station Parameters) message:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&20.\ \&Reference Station Parameters
.TS
allbox tab(:);
lB lB lB.
T{
Name
T}:T{
Type
T}:T{
.PP
Description
T}
.T&
l l l
l l l
l l l.
T{
x
T}:T{
real
T}:T{
.PP
ECEF X coordinate\&.
T}
T{
y
T}:T{
real
T}:T{
.PP
ECEF Y coordinate\&.
T}
T{
z
T}:T{
real
T}:T{
.PP
ECEF Z coordinate\&.
T}
.TE
.sp 1
.PP
The coordinates are the position of the station, in meters to two decimal places, in Earth Centred Earth Fixed coordinates\&. These are usually referred to the WGS84 reference frame, but may be referred to NAD83 in the US (essentially identical to WGS84 for all except geodesists), or to some other reference frame in other parts of the world\&.
.PP
An invalid reference message is represented by a type 3 header without payload fields\&.
.PP
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"RTCM2","type":3,
    "station_id":652,"zcount":1657\&.2,"seqnum":2,"length":4,"station_health":6,
    "x":3878620\&.92,"y":670281\&.40,"z":5002093\&.59
}
.fi
.if n \{\
.RE
.\}
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBType 4: Datum\fR
.RS 4
.PP
Here are the payload members of a type 4 (Datum) message:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&21.\ \&Datum
.TS
allbox tab(:);
lB lB lB.
T{
Name
T}:T{
Type
T}:T{
.PP
Description
T}
.T&
l l l
l l l
l l l
l l l
l l l
l l l.
T{
dgnss_type
T}:T{
string
T}:T{
.PP
Either "GPS", "GLONASS", "GALILEO", or "UNKNOWN"\&.
T}
T{
dat
T}:T{
integer
T}:T{
.PP
0 or 1 and indicates the sense of the offset shift given by dx, dy, dz\&. dat = 0 means that the station coordinates (in the reference message) are referred to a local datum and that adding dx, dy, dz to that position will render it in GNSS coordinates (WGS84 for GPS)\&. If dat = 1 then the ref station position is in GNSS coordinates and adding dx, dy, dz will give it referred to the local datum\&.
T}
T{
datum_name
T}:T{
string
T}:T{
.PP
A standard name for the datum\&.
T}
T{
dx
T}:T{
real
T}:T{
.PP
X offset\&.
T}
T{
dy
T}:T{
real
T}:T{
.PP
Y offset\&.
T}
T{
dz
T}:T{
real
T}:T{
.PP
Z offset\&.
T}
.TE
.sp 1
.PP
<dx> <dy> <dz> are offsets to convert from local datum to GNSS datum or vice versa\&. These fields are optional\&.
.PP
An invalid datum message is represented by a type 4 header without payload fields\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBType 5: Constellation Health\fR
.RS 4
.PP
One or more of these follow the header for type 5 messages \(em one for each satellite\&.
.PP
Here is the format:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&22.\ \&Constellation health
.TS
allbox tab(:);
lB lB lB.
T{
Name
T}:T{
Type
T}:T{
.PP
Description
T}
.T&
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l.
T{
ident
T}:T{
integer
T}:T{
.PP
The PRN number of the satellite\&.
T}
T{
iodl
T}:T{
bool
T}:T{
.PP
True indicates that this information relates to the satellite information in an accompanying type 1 or type 9 message\&.
T}
T{
health
T}:T{
integer
T}:T{
0 indicates that the satellite is healthy\&. Any other value
	indicates a problem (coding is not known)\&..PP
T}
T{
snr
T}:T{
integer
T}:T{
.PP
The carrier/noise ratio of the received signal in the range 25 to 55 dB(Hz)\&.
T}
T{
health_en
T}:T{
bool
T}:T{
.PP
If set to True it indicates that the satellite is healthy even if the satellite navigation data says it is unhealthy\&.
T}
T{
new_data
T}:T{
bool
T}:T{
True indicates that the IOD for this satellite will
        soon be updated in type 1 or 9 messages\&..PP
T}
T{
los_warning
T}:T{
bool
T}:T{
.PP
Line\-of\-sight warning\&. True indicates that the satellite will shortly go unhealthy\&.
T}
T{
tou
T}:T{
integer
T}:T{
.PP
Healthy time remaining in seconds\&.
T}
.TE
.sp 1
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBType 6: Null\fR
.RS 4
.PP
This just indicates a null message\&. There are no payload fields\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBUnknown message\fR
.RS 4
.PP
This format is used to dump message words in hexadecimal when the message type field doesn\*(Aqt match any of the known ones\&.
.PP
Here is the format:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&23.\ \&Unknown Message
.TS
allbox tab(:);
lB lB lB.
T{
Name
T}:T{
Type
T}:T{
.PP
Description
T}
.T&
l l l.
T{
data
T}:T{
list
T}:T{
.PP
A list of strings\&.
T}
.TE
.sp 1
.PP
Each string in the array is a hex literal representing 30 bits of information, after parity checks and inversion\&. The high two bits should be ignored\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBType 7: Radio Beacon Almanac\fR
.RS 4
.PP
Here is the format:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&24.\ \&Contellation health
.TS
allbox tab(:);
lB lB lB.
T{
Name
T}:T{
Type
T}:T{
.PP
Description
T}
.T&
l l l
l l l
l l l
l l l
l l l
l l l
l l l.
T{
lat
T}:T{
real
T}:T{
.PP
Latitude in degrees, of the LF transmitter antenna for the station for which this is an almanac\&. North is positive\&.
T}
T{
lon
T}:T{
real
T}:T{
.PP
Longitude in degrees, of the LF transmitter antenna for the station for which this is an almanac\&. East is positive\&.
T}
T{
range
T}:T{
integer
T}:T{
Published range of the station in km\&..PP
T}
T{
frequency
T}:T{
real
T}:T{
.PP
Station broadcast frequency in kHz\&.
T}
T{
health
T}:T{
integer
T}:T{
.PP
<health> is the health of the station for which this is an almanac\&. If it is non\-zero, the station is issuing suspect data and should not be used for fixes\&. The ITU and RTCM104 standards differ about the mode detailed interpretation of the <health> field and even about its bit width\&.
T}
T{
station_id
T}:T{
integer
T}:T{
.PP
The id of the transmitter\&. This is not the same as the reference id in the header, the latter being the id of the reference receiver\&.
T}
T{
bitrate
T}:T{
integer
T}:T{
.PP
The transmitted bitrate\&.
T}
.TE
.sp 1
.PP
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"RTCM2","type":9,"station_id":268,"zcount":252\&.6,
        "seqnum":4,"length":5,"station_health":0,
        "satellites":[
            {"ident":13,"udre":0,"iod":3,"prc":\-25\&.940,"rrc":0\&.066},
            {"ident":2,"udre":0,"iod":73,"prc":0\&.920,"rrc":\-0\&.080},
            {"ident":8,"udre":0,"iod":22,"prc":23\&.820,"rrc":0\&.014}
]}
.fi
.if n \{\
.RE
.\}
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBType 13: GPS Time of Week\fR
.RS 4
.PP
Here are the payload members of a type 13 (Groumf Tramitter Parameters) message:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&25.\ \&Grund Transmitter Parameters
.TS
allbox tab(:);
lB lB lB.
T{
Name
T}:T{
Type
T}:T{
.PP
Description
T}
.T&
l l l
l l l
l l l
l l l
l l l.
T{
status
T}:T{
bool
T}:T{
.PP
If True, signals user to expect a type 16 explanatory message associated with this station\&. Probably indicates some sort of unusual event\&.
T}
T{
rangeflag
T}:T{
bool
T}:T{
.PP
If True, indicates that the estimated range is different from that found in the Type 7 message (which contains the beacon\*(Aqs listed range)\&. Generally indicates a range reduction due to causes such as poor ionospheric conditions or reduced transmission power\&.
T}
T{
lat
T}:T{
real
T}:T{
.PP
Degrees latitude, signed\&. Positive is N, negative is S\&.
T}
T{
lon
T}:T{
real
T}:T{
.PP
Degrees longitude, signed\&. Positive is E, negative is W\&.
T}
T{
range
T}:T{
integer
T}:T{
.PP
Transmission range in km (1\-1024)\&.
T}
.TE
.sp 1
.PP
This message type replaces message type 3 (Reference Station Parameters) in RTCM 2\&.3\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBType 14: GPS Time of Week\fR
.RS 4
.PP
Here are the payload members of a type 14 (GPS Time of Week) message:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&26.\ \&Reference Station Parameters
.TS
allbox tab(:);
lB lB lB.
T{
Name
T}:T{
Type
T}:T{
.PP
Description
T}
.T&
l l l
l l l
l l l.
T{
week
T}:T{
integer
T}:T{
.PP
GPS week (0\-123)\&.
T}
T{
hour
T}:T{
integer
T}:T{
.PP
Hour of week (0\-167)\&.
T}
T{
leapsecs
T}:T{
integer
T}:T{
.PP
Leap Seconds (0\-63)\&.
T}
.TE
.sp 1
.PP
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"RTCM2","type":14,"station_id":652,"zcount":1657\&.2,
        "seqnum":3,"length":1,"station_health":6,"week":601,"hour":109,
        "leapsecs":15}
.fi
.if n \{\
.RE
.\}
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBType 16: Special Message\fR
.RS 4
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&27.\ \&Special Message
.TS
allbox tab(:);
lB lB lB.
T{
Name
T}:T{
Type
T}:T{
.PP
Description
T}
.T&
l l l.
T{
message
T}:T{
string
T}:T{
.PP
A text message sent by the beacon operator\&.
T}
.TE
.sp 1
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBType 31: Correction data\fR
.RS 4
.PP
One or more GLONASS satellite objects follow the header for type 1 or type 9 messages\&. Here is the format:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&28.\ \&Satellite object
.TS
allbox tab(:);
lB lB lB.
T{
Name
T}:T{
Type
T}:T{
.PP
Description
T}
.T&
l l l
l l l
l l l
l l l
l l l
l l l.
T{
ident
T}:T{
integer
T}:T{
.PP
The PRN number of the satellite for which this is correction data\&.
T}
T{
udre
T}:T{
integer
T}:T{
.PP
User Differential Range Error (0\-3)\&. See the table following for values\&.
T}
T{
change
T}:T{
boolean
T}:T{
.PP
Change\-of\-ephemeris bit\&.
T}
T{
tod
T}:T{
uinteger
T}:T{
.PP
Count of 30\-second periods since the top of the hour\&.
T}
T{
prc
T}:T{
real
T}:T{
.PP
The pseudorange error in meters for this satellite as measured by the beacon reference receiver at the epoch indicated by the z_count in the parent record\&.
T}
T{
rrc
T}:T{
real
T}:T{
.PP
The rate of change of pseudorange error in meters/sec for this satellite as measured by the beacon reference receiver at the epoch indicated by the z_count field in the parent record\&. This is used to calculate pseudorange errors at other epochs, if required by the GPS receiver\&.
T}
.TE
.sp 1
.PP
Here\*(Aqs an example:
.sp
.if n \{\
.RS 4
.\}
.nf
{"class":"RTCM2","type":31,"station_id":652,"zcount":1642\&.2,
    "seqnum":0,"length":14,"station_health":6,
    "satellites":[
        {"ident":5,"udre":0,"change":false,"tod":0,"prc":132\&.360,"rrc":0\&.000},
        {"ident":15,"udre":0,"change":false,"tod":0,"prc":134\&.840,"rrc":0\&.002},
        {"ident":14,"udre":0,"change":false,"tod":0,"prc":141\&.520,"rrc":0\&.000},
        {"ident":6,"udre":0,"change":false,"tod":0,"prc":127\&.000,"rrc":0\&.000},
        {"ident":21,"udre":0,"change":false,"tod":0,"prc":128\&.780,"rrc":0\&.000},
        {"ident":22,"udre":0,"change":false,"tod":0,"prc":125\&.260,"rrc":0\&.002},
        {"ident":20,"udre":0,"change":false,"tod":0,"prc":117\&.280,"rrc":\-0\&.004},
        {"ident":16,"udre":0,"change":false,"tod":17,"prc":113\&.460,"rrc":0\&.018}
]}
.fi
.if n \{\
.RE
.\}
.RE
.SH "RTCM3 DUMP FORMAT"
.PP
The support for RTCM104v3 dumping is incomplete and buggy\&. Do not attempt to use it for production! Anyone interested in it should read the source code\&.
.SH "AIS DUMP FORMATS"
.PP
AIS support is an extension\&. It may not be present if your instance of
gpsd
has been built with a restricted feature set\&.
.PP
AIS packets are dumped as JSON objects with class "AIS"\&. Each AIS report object contains a "type" field giving the AIS message type and a "scaled" field telling whether the remainder of the fields are dumped in scaled or unscaled form\&. (These will be emitted before any type\-specific fields\&.) It will also contain a "device" field naming the data source\&. Other fields have names and types as specified in the
AIVDM/AIVDO Protocol Decoding
document on the GPSD project website; each message field table may be directly interpreted as a specification for the members of the corresponding JSON object type\&.
.PP
By default, certain scaling and conversion operations are performed for JSON output\&. Latitudes and longitudes are scaled to decimal degrees rather than the native AIS unit of 1/10000th of a minute of arc\&. Ship (but not air) speeds are scaled to knots rather than tenth\-of\-knot units\&. Rate of turn may appear as "nan" if is unavailable, or as one of the strings "fastright" or "fastleft" if it is out of the AIS encoding range; otherwise it is quadratically mapped back to the turn sensor number in degrees per minute\&. Vessel draughts are converted to decimal meters rather than native AIS decimeters\&. Various other scaling conversions are described in
"AIVDM/AIVDO Protocol Decoding"\&.
.SH "SUBFRAME DUMP FORMATS"
.PP
Subframe support is always compiled into
gpsd
but many GPSes do not output subframe data or the
gpsd
driver may not support subframes\&.
.PP
Subframe packets are dumped as JSON objects with class "SUBFRAME"\&. Each subframe report object contains a "frame" field giving the subframe number, a "tSV" field for the transmitting satellite number, a "TOW17" field containing the 17 MSBs of the start of the next 12\-second message and a "scaled" field telling whether the remainder of the fields are dumped in scaled or unscaled form\&. It will also contain a "device" field naming the data source\&. Each SUBFRAME object will have a sub\-object specific to that subframe page type\&. Those sub\-object fields have names and types similar to those specified in the IS\-GPS\-200E document; each message field table may be directly interpreted as a specification for the members of the corresponding JSON object type\&.
.SH "SEE ALSO"
.PP
\fBgpsd\fR(8),
\fBlibgps\fR(3),
.SH "AUTHOR"
.PP
The protocol was designed and documented by Eric S\&. Raymond\&.
.SH "NOTES"
.IP " 1." 4
Radio Technical Commission for Maritime Services
.RS 4
\%http://www.rtcm.org/
.RE
.IP " 2." 4
table of leap second corrections
.RS 4
\%ftp://maia.usno.navy.mil/ser7/tai-utc.dat
.RE
