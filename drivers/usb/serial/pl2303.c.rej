--- drivers/usb/serial/pl2303.c
+++ drivers/usb/serial/pl2303.c
@@ -134,6 +136,22 @@ MODULE_DEVICE_TABLE(usb, id_table);
 #define UART_OVERRUN_ERROR		0x40
 #define UART_CTS			0x80
 
+#define HXD_GPIO_01_CTRL		0x0001
+#define HXD_GPIO_01_VALUE		0x0081
+#define HXD_GPIO_23_DIR_CTRL		0x0c0c
+#define HXD_GPIO_23_VALUE_CTRL		0x0d0d
+#define HXD_GPIO_23_VALUE		0x8d8d
+
+#define HXD_GPIO0_DIR_MASK		0x10
+#define HXD_GPIO1_DIR_MASK		0x20
+#define HXD_GPIO2_DIR_MASK		0x03
+#define HXD_GPIO3_DIR_MASK		0x0c
+
+#define HXD_GPIO0_VALUE_MASK		0x40
+#define HXD_GPIO1_VALUE_MASK		0x80
+#define HXD_GPIO2_VALUE_MASK		0x01
+#define HXD_GPIO3_VALUE_MASK		0x02
+
 
 enum pl2303_type {
 	TYPE_01,	/* Type 0 and 1 (difference unknown) */
@@ -227,11 +256,213 @@ static int pl2303_probe(struct usb_serial *serial,
 	return 0;
 }
 
+#ifdef CONFIG_USB_SERIAL_PL2303_GPIO
+struct pl2303_gpio_desc {
+	u8 dir_offset;
+	u8 dir_mask;
+	u16 dir_ctrl;
+	u8 value_offset;
+	u8 value_mask;
+	u16 value_ctrl;
+	u16 read_ctrl;
+};
+
+struct pl2303_gpio {
+	struct pl2303_gpio_desc *descs;
+	u8 data[3];
+	struct mutex lock;
+	struct usb_serial *serial;
+	struct gpio_chip gpio_chip;
+};
+
+static inline struct pl2303_gpio *to_pl2303_gpio(struct gpio_chip *chip)
+{
+	return container_of(chip, struct pl2303_gpio, gpio_chip);
+}
+
+static void pl2303_gpio_add(struct usb_serial *serial, u8 num, u16 read_ctrl,
+			u8 dir_offset, u8 dir_mask, u16 dir_ctrl,
+			u8 value_offset, u8 value_mask, u16 value_ctrl)
+{
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
+	struct pl2303_gpio *gpio = spriv->gpio;
+
+	BUG_ON(num >= spriv->ngpio);
+	gpio->descs[num].dir_offset = dir_offset;
+	gpio->descs[num].dir_mask = dir_mask;
+	gpio->descs[num].dir_ctrl = dir_ctrl;
+
+	gpio->descs[num].value_offset = value_offset;
+	gpio->descs[num].value_mask = value_mask;
+	gpio->descs[num].value_ctrl = value_ctrl;
+
+	gpio->descs[num].read_ctrl = read_ctrl;
+}
+
+static int pl2303_gpio_direction_in(struct gpio_chip *chip, unsigned offset)
+{
+	struct pl2303_gpio *gpio = to_pl2303_gpio(chip);
+	struct pl2303_gpio_desc *desc;
+	int ret;
+
+	mutex_lock(&gpio->lock);
+	desc = gpio->descs+offset;
+	gpio->data[desc->dir_offset] &= ~desc->dir_mask;
+	ret = pl2303_vendor_write(gpio->serial, desc->dir_ctrl,
+				gpio->data[desc->dir_offset]);
+	mutex_unlock(&gpio->lock);
+
+	return ret;
+}
+
+static int pl2303_gpio_direction_out(struct gpio_chip *chip,
+				unsigned offset, int value)
+{
+	struct pl2303_gpio *gpio = to_pl2303_gpio(chip);
+	struct pl2303_gpio_desc *desc;
+	int ret;
+
+	mutex_lock(&gpio->lock);
+	desc = gpio->descs+offset;
+	gpio->data[desc->dir_offset] |= desc->dir_mask;
+	ret = pl2303_vendor_write(gpio->serial, desc->dir_ctrl,
+				gpio->data[desc->dir_offset]);
+	if (ret)
+		goto error;
+
+	if (value)
+		gpio->data[desc->value_offset] |= desc->value_mask;
+	else
+		gpio->data[desc->value_offset] &= ~desc->value_mask;
+
+	ret = pl2303_vendor_write(gpio->serial, desc->value_ctrl,
+				gpio->data[desc->value_offset]);
+error:
+	mutex_unlock(&gpio->lock);
+
+	return ret;
+}
+
+static void pl2303_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct pl2303_gpio *gpio = to_pl2303_gpio(chip);
+	struct pl2303_gpio_desc *desc;
+
+	mutex_lock(&gpio->lock);
+	desc = gpio->descs+offset;
+	if (value)
+		gpio->data[desc->value_offset] |= desc->value_mask;
+	else
+		gpio->data[desc->value_offset] &= ~desc->value_mask;
+
+	pl2303_vendor_write(gpio->serial, desc->value_ctrl,
+			gpio->data[desc->value_offset]);
+	mutex_unlock(&gpio->lock);
+}
+
+static int pl2303_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct pl2303_gpio *gpio = to_pl2303_gpio(chip);
+	struct pl2303_gpio_desc *desc;
+	unsigned char *buf;
+	int value;
+
+	buf = kzalloc(1, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	mutex_lock(&gpio->lock);
+	desc = gpio->descs+offset;
+
+	if (pl2303_vendor_read(gpio->serial, desc->read_ctrl, buf)) {
+		mutex_unlock(&gpio->lock);
+		return -EIO;
+	}
+
+	value = buf[0] & desc->value_mask;
+	mutex_unlock(&gpio->lock);
+	kfree(buf);
+
+	return value;
+}
+
+static int pl2303_gpio_startup(struct usb_serial *serial)
+{
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
+	struct pl2303_gpio *gpio;
+	int ret;
+
+	gpio = kzalloc(sizeof(struct pl2303_gpio), GFP_KERNEL);
+	if (!gpio)
+		return -ENOMEM;
+
+	gpio->descs = kcalloc(spriv->ngpio, sizeof(struct pl2303_gpio_desc),
+			GFP_KERNEL);
+	if (!gpio->descs) {
+		kfree(gpio);
+		return -ENOMEM;
+	}
+	spriv->gpio = gpio;
+
+	pl2303_gpio_add(serial, 0, HXD_GPIO_01_VALUE,
+			0, HXD_GPIO0_DIR_MASK, HXD_GPIO_01_CTRL,
+			0, HXD_GPIO0_VALUE_MASK, HXD_GPIO_01_CTRL);
+	pl2303_gpio_add(serial, 1, HXD_GPIO_01_VALUE,
+			0, HXD_GPIO1_DIR_MASK, HXD_GPIO_01_CTRL,
+			0, HXD_GPIO1_VALUE_MASK, HXD_GPIO_01_CTRL);
+
+	if (spriv->ngpio == 4) {
+		pl2303_gpio_add(serial, 2, HXD_GPIO_23_VALUE,
+				1, HXD_GPIO2_DIR_MASK, HXD_GPIO_23_DIR_CTRL,
+				2, HXD_GPIO2_VALUE_MASK,
+				HXD_GPIO_23_VALUE_CTRL);
+		pl2303_gpio_add(serial, 3, HXD_GPIO_23_VALUE,
+				1, HXD_GPIO3_DIR_MASK, HXD_GPIO_23_DIR_CTRL,
+				2, HXD_GPIO3_VALUE_MASK,
+				HXD_GPIO_23_VALUE_CTRL);
+	}
+
+	gpio->serial = serial;
+	mutex_init(&gpio->lock);
+
+	gpio->gpio_chip.label = "pl2303";
+	gpio->gpio_chip.owner = THIS_MODULE;
+	gpio->gpio_chip.direction_input = pl2303_gpio_direction_in;
+	gpio->gpio_chip.get = pl2303_gpio_get;
+	gpio->gpio_chip.direction_output = pl2303_gpio_direction_out;
+	gpio->gpio_chip.set = pl2303_gpio_set;
+	gpio->gpio_chip.can_sleep  = true;
+	gpio->gpio_chip.ngpio = spriv->ngpio;
+	gpio->gpio_chip.base = -1;
+	gpio->gpio_chip.dev = &serial->interface->dev;
+
+	ret = gpiochip_add(&gpio->gpio_chip);
+	if (ret < 0) {
+		kfree(gpio);
+		return ret;
+	}
+	return 0;
+}
+
+static void pl2303_gpio_release(struct usb_serial *serial)
+{
+	struct pl2303_serial_private *spriv = usb_get_serial_data(serial);
+	struct pl2303_gpio *gpio = (struct pl2303_gpio *)spriv->gpio;
+
+	gpiochip_remove(&gpio->gpio_chip);
+	kfree(gpio->descs);
+	kfree(gpio);
+}
+#endif
+
 static int pl2303_startup(struct usb_serial *serial)
 {
 	struct pl2303_serial_private *spriv;
 	enum pl2303_type type = TYPE_01;
 	unsigned char *buf;
+	u16 bcdDevice;
+	u8 major_revision;
+	int ret;
 
 	spriv = kzalloc(sizeof(*spriv), GFP_KERNEL);
 	if (!spriv)
